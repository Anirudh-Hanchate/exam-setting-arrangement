<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Automated Exam Seating Generator</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.min.js"></script>

    <style>
        body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; background-color: #f4f7f6; color: #333; margin: 0; padding: 2rem; }
        .container { max-width: 900px; margin: 0 auto; background: #fff; padding: 2rem; border-radius: 8px; box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08); }
        h1 { text-align: center; color: #2c3e50; margin-bottom: 2rem; }
        form { display: flex; flex-direction: column; gap: 1.5rem; }
        fieldset { border: 1px solid #ddd; border-radius: 5px; padding: 1.5rem; }
        legend { font-weight: 600; color: #3498db; padding: 0 0.5rem; }
        .form-group { display: flex; flex-direction: column; }
        label { margin-bottom: 0.5rem; font-size: 0.9rem; font-weight: 500; }
        input[type="text"], input[type="number"], input[type="file"] { padding: 0.75rem; border: 1px solid #ccc; border-radius: 4px; font-size: 1rem; transition: border-color 0.2s, box-shadow 0.2s; box-sizing: border-box; width: 100%; }
        input:focus { outline: none; border-color: #3498db; box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2); }
        input[type="file"] { padding: 0.6rem; }
        .room-group { display: grid; grid-template-columns: 3fr 1fr 1fr auto; gap: 1rem; align-items: flex-end; padding: 1rem; border-radius: 5px; background-color: #f9f9f9; margin-bottom: 1rem; border-left: 3px solid #3498db; }
        .branch-group-wrapper { padding: 1rem; border-radius: 5px; background-color: #f9f9f9; margin-bottom: 1rem; border-left: 3px solid #2ecc71; }
        .branch-group { display: grid; grid-template-columns: 2fr 3fr 1fr 1fr auto; gap: 1rem; align-items: flex-end; }
        .remove-btn { background: #e74c3c; color: white; border: none; border-radius: 4px; padding: 0.75rem; cursor: pointer; font-weight: bold; transition: background-color 0.2s; height: 100%; }
        .actions { text-align: left; margin-top: -0.5rem; margin-bottom: 1rem; }
        .add-btn { background: #2ecc71; color: white; border: none; padding: 0.7rem 1.2rem; border-radius: 4px; cursor: pointer; font-weight: 500; margin-right: 10px; }
        .submit-btn { background: #3498db; color: white; border: none; padding: 1rem; font-size: 1.1rem; font-weight: bold; border-radius: 4px; cursor: pointer; }
        #statusContainer{margin-top:1.5rem}#status{padding:1rem;border-radius:5px}.status-error{background-color:#ffebee;color:#c62828}.status-warning{background-color:#fffde7;color:#f57f17}.status-info{background-color:#e3f2fd;color:#1565c0}.status-loading{background-color:#e1f5fe;color:#0277bd;text-align:center}
        #resultsContainer{margin-top:2rem}
        .results-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:1rem;flex-wrap: wrap;}
        .export-btn{background-color:#1abc9c;color:#fff;border:none;padding:.7rem 1.2rem;border-radius:4px;cursor:pointer;font-weight:500;margin-left:.5rem;margin-top: 0.5rem;}
        .export-btn:hover{background-color: #16a085;}
        .report-btn{background-color:#9b59b6;}.report-btn:hover{background-color:#8e44ad;}
        .room-plan-group { margin-bottom: 2.5rem; }
        .room-plan-group > h2 { color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 0.5rem; }
        table{width:100%;border-collapse:collapse;margin-top:1rem}th,td{border:1px solid #ddd;padding:.8rem;text-align:center}th{background-color:#f2f2f2;font-weight:600}
    </style>
</head>
<body>
    <div class="container">
        <h1>Exam Seat Arrangement</h1>
        <form id="seatingForm">
            <fieldset>
                <legend>1. Global Bench Configuration</legend>
                 <div class="form-group">
                    <label for="studentsPerBenchInput">Number of Students per Bench (applies to all rooms)</label>
                    <input type="number" id="studentsPerBenchInput" min="1" required value="2">
                    <small style="font-size: 0.8rem; color: #666; margin-top: 5px;">The system will automatically create the best seating pattern (e.g., 2 creates A,B; 3 creates A,B,A).</small>
                </div>
            </fieldset>
            <fieldset>
                <legend>2. Common Paper Groups (Optional)</legend>
                <div class="form-group">
                    <label for="commonGroupsInput">Group branches with the same exam paper (Branches that CANNOT sit together)</label>
                    <input type="text" id="commonGroupsInput" placeholder="e.g., CS,AI; ECE,EEE">
                    <small style="font-size: 0.8rem; color: #666; margin-top: 5px;">Enter pairs separated by a comma, multiple pairs by a semicolon (;). These branches cannot sit together.</small>
                </div>
            </fieldset>
            
            <fieldset>
                <legend>3. Upload Room Plan (Optional)</legend>
                <div class="form-group">
                    <label for="roomPlanUpload">Upload PDF or Excel file of the room layout</label>
                    <input type="file" id="roomPlanUpload" accept=".pdf, .xlsx, .xls">
                    <small style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                        <b>Format:</b> Col 1: Room Name, Col 2: Total Benches, Col 3: # of Columns, Col 4+: Benches in each specific column.
                    </small>
                </div>
            </fieldset>

            <fieldset>
                <legend>4. Room Definitions (Manual Entry / From Upload)</legend>
                <div id="roomContainer"></div><div class="actions"><button type="button" class="add-btn" id="addRoomBtn" style="background-color: #3498db;">+ Add Room</button></div>
            </fieldset>
            <fieldset>
                <legend>5. Branch / Section Definitions</legend>
                <div id="branchContainer"></div><div class="actions"><button type="button" class="add-btn" id="addBranchBtn">+ Add Branch</button></div>
            </fieldset>
            <button type="submit" class="submit-btn">Generate Seating Plan</button>
        </form>
        <div id="statusContainer"></div>
        <div id="resultsContainer"></div>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const form = document.getElementById('seatingForm');
        const roomContainer = document.getElementById('roomContainer');
        const addRoomBtn = document.getElementById('addRoomBtn');
        const branchContainer = document.getElementById('branchContainer');
        const addBranchBtn = document.getElementById('addBranchBtn');
        const statusContainer = document.getElementById('statusContainer');
        const resultsContainer = document.getElementById('resultsContainer');
        const roomPlanUpload = document.getElementById('roomPlanUpload');
        let lastSuccessfulResult = null;

        if (window.pdfjsLib) {
             pdfjsLib.GlobalWorkerOptions.workerSrc = `https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js`;
        }
       
        const addRoomGroup = () => {
            const roomId = `room-${Date.now()}`;
            const roomGroup = document.createElement('div');
            roomGroup.className = 'room-group';
            roomGroup.id = roomId;
            roomGroup.innerHTML = `
                <div class="form-group"><label>Room Name/No.</label><input type="text" class="room-name" placeholder="e.g., Room 101" required></div>
                <div class="form-group"><label>Total Benches</label><input type="number" class="room-benches" min="1" required placeholder="e.g., 40"></div>
                <div class="form-group"><label>Class Columns</label><input type="number" class="room-columns" min="1" required placeholder="e.g., 3"></div>
                <input type="hidden" class="room-benches-distribution">
                <button type="button" class="remove-btn" onclick="document.getElementById('${roomId}').remove()">X</button>
            `;
            roomContainer.appendChild(roomGroup);
        };

        const addBranchGroup = () => {
            const branchId = `branch-${Date.now()}`;
            const branchWrapper = document.createElement('div');
            branchWrapper.className = 'branch-group-wrapper';
            branchWrapper.id = branchId;
            branchWrapper.innerHTML = `
                <div class="branch-group"><div class="form-group"><label>Branch Name</label><input type="text" class="branch-name" placeholder="e.g., AIML" required></div><div class="form-group"><label>USN Prefix</label><input type="text" class="branch-prefix" placeholder="e.g., 1XX21AI" required></div><div class="form-group"><label>Start No.</label><input type="number" class="branch-start" placeholder="e.g., 1" min="1" required></div><div class="form-group"><label>End No.</label><input type="number" class="branch-end" placeholder="e.g., 90" min="1" required></div><button type="button" class="remove-btn" onclick="document.getElementById('${branchId}').remove()">X</button></div>
                <div class="form-group" style="padding:0 1rem .5rem;margin-top:.5rem"><label>Skip USN Numbers (comma-separated)</label><input type="text" class="branch-skip" placeholder="e.g., 5, 12, 45"></div>
            `;
            branchContainer.appendChild(branchWrapper);
        };
        
        const populateRoomsUI = (rooms) => {
            roomContainer.innerHTML = '';
            rooms.forEach(room => {
                const roomId = `room-${Date.now()}-${Math.random()}`;
                const roomGroup = document.createElement('div');
                roomGroup.className = 'room-group';
                roomGroup.id = roomId;
                roomGroup.innerHTML = `
                    <div class="form-group"><label>Room Name/No.</label><input type="text" class="room-name" required></div>
                    <div class="form-group"><label>Total Benches</label><input type="number" class="room-benches" min="1" required></div>
                    <div class="form-group"><label>Class Columns</label><input type="number" class="room-columns" min="1" required></div>
                    <input type="hidden" class="room-benches-distribution">
                    <button type="button" class="remove-btn" onclick="document.getElementById('${roomId}').remove()">X</button>
                `;
                roomContainer.appendChild(roomGroup);
                roomGroup.querySelector('.room-name').value = room.name || '';
                roomGroup.querySelector('.room-benches').value = room.benches || '';
                roomGroup.querySelector('.room-columns').value = room.classColumns || '';
                if (room.benchesInColumns && room.benchesInColumns.length > 0) {
                    roomGroup.querySelector('.room-benches-distribution').value = room.benchesInColumns.join(',');
                }
            });
        };

        const parseRoomDataFromRows = (rows) => {
            const roomData = [];
            rows.forEach((row, index) => {
                if (index === 0 && (isNaN(parseInt(row[1])) || isNaN(parseInt(row[2])))) return;
                if (!row || row.length < 3) return;
                const name = String(row[0] || '').trim();
                const totalBenches = parseInt(row[1]);
                const numColumns = parseInt(row[2]);
                if (!name || isNaN(totalBenches) || isNaN(numColumns)) return;
                const benchesInColumns = row.slice(3, 3 + numColumns).map(Number);
                const isValidDistribution = benchesInColumns.length === numColumns && !benchesInColumns.some(isNaN) && benchesInColumns.reduce((a, b) => a + b, 0) === totalBenches;
                roomData.push({ name: name, benches: totalBenches, classColumns: numColumns, benchesInColumns: isValidDistribution ? benchesInColumns : [] });
            });
            return roomData;
        };

        const handleExcelFile = (file) => {
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const firstSheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[firstSheetName];
                    const jsonRows = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval:"" });
                    const rooms = parseRoomDataFromRows(jsonRows);
                    populateRoomsUI(rooms);
                    statusContainer.innerHTML = `<div id="status" class="status-info">Successfully parsed ${rooms.length} rooms from Excel. You can now review them below.</div>`;
                } catch (error) { statusContainer.innerHTML = `<div id="status" class="status-error"><b>Error:</b> Could not parse Excel file.</div>`; }
            };
            reader.readAsArrayBuffer(file);
        };
        
        const handlePdfFile = (file) => {
            const reader = new FileReader();
            reader.onload = async (e) => {
                const typedarray = new Uint8Array(e.target.result);
                try {
                    const pdf = await pdfjsLib.getDocument(typedarray).promise;
                    let allRows = [];
                    for (let i = 1; i <= pdf.numPages; i++) {
                        const page = await pdf.getPage(i);
                        const textContent = await page.getTextContent();
                        if (textContent.items.length === 0) continue;
                        const lines = new Map();
                        textContent.items.forEach(item => { const y = Math.round(item.transform[5]); if (!lines.has(y)) lines.set(y, []); lines.get(y).push({ x: item.transform[4], text: item.str }); });
                        const sortedLines = Array.from(lines.entries()).sort((a, b) => b[0] - a[0]);
                        sortedLines.forEach(([y, items]) => { const rowText = items.sort((a, b) => a.x - b.x).map(item => item.text).join(' '); const cells = rowText.split(/\s{2,}/).map(s => s.trim()).filter(Boolean); if (cells.length > 1) allRows.push(cells); });
                    }
                    const rooms = parseRoomDataFromRows(allRows);
                    populateRoomsUI(rooms);
                    statusContainer.innerHTML = `<div id="status" class="status-info">Successfully parsed ${rooms.length} rooms from PDF. You can now review them below.</div>`;
                } catch (error) { statusContainer.innerHTML = `<div id="status" class="status-error"><b>Error:</b> Could not parse PDF. It might be an image or have a complex format.</div>`; }
            };
            reader.readAsArrayBuffer(file);
        };

        roomPlanUpload.addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) return;
            const fileName = file.name.toLowerCase();
            if (fileName.endsWith('.xlsx') || fileName.endsWith('.xls')) { handleExcelFile(file); } else if (fileName.endsWith('.pdf')) { handlePdfFile(file); } else { alert('Unsupported file type. Please upload a PDF or Excel file.');}
            event.target.value = null;
        });

        addRoomBtn.addEventListener('click', addRoomGroup);
        addBranchBtn.addEventListener('click', addBranchGroup);
        
        form.addEventListener('submit', async e => {
            e.preventDefault();
            statusContainer.innerHTML = '<div id="status" class="status-loading">Generating plan...</div>';
            resultsContainer.innerHTML = "";
            lastSuccessfulResult = null;
            const allotmentData = { studentsPerBench: document.getElementById("studentsPerBenchInput").value, commonPaperGroups: document.getElementById("commonGroupsInput").value, roomConfigurations: [], branchDetails: [] };
            document.querySelectorAll(".room-group").forEach(group => {
                const roomConfig = { name: group.querySelector(".room-name").value, benches: group.querySelector(".room-benches").value, classColumns: group.querySelector(".room-columns").value, };
                const distribution = group.querySelector(".room-benches-distribution").value;
                if (distribution) { roomConfig.benchesInColumns = distribution.split(',').map(Number); }
                allotmentData.roomConfigurations.push(roomConfig);
            });
            document.querySelectorAll(".branch-group-wrapper").forEach(group => { allotmentData.branchDetails.push({ name: group.querySelector(".branch-name").value, prefix: group.querySelector(".branch-prefix").value, start: group.querySelector(".branch-start").value, end: group.querySelector(".branch-end").value, skip: group.querySelector(".branch-skip").value }); });
            try {
                const response = await fetch("http://127.0.0.1:5000/api/generate-allotment", { method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(allotmentData) });
                const result = await response.json();
                if (response.ok && result.status === "success") { statusContainer.innerHTML = ""; lastSuccessfulResult = result; displayResults(result); } else { throw new Error(result.message || "An unknown server error occurred."); }
            } catch (error) { statusContainer.innerHTML = `<div id="status" class="status-error"><b>Error:</b> ${error.message}</div>`; console.error("API Error:", error); }
        });

        addRoomGroup(); addBranchGroup();

        const exportSummaryReport = () => { if (!lastSuccessfulResult) return; const { jsPDF } = window.jspdf; const doc = new jsPDF({ orientation: 'p', unit: 'mm', format: 'a4' }); doc.setFontSize(18); doc.text("Exam Administration Summary Report", 14, 22); let startY = 30; const addReportSection = (title, data, columns, color) => { if (!data || Object.keys(data).length === 0) return; const filteredData = Object.entries(data).filter(([key, values]) => values.length > 0); if(filteredData.length === 0) return; if (startY > 240) { doc.addPage(); startY = 22; } doc.setFontSize(14); doc.text(title, 14, startY); const body = filteredData.map(([key, values]) => [key, Array.isArray(values) ? values.join(', ') : `${values.length} student(s)`]); doc.autoTable({ head: [columns], body: body, startY: startY + 6, theme: 'striped', headStyles: { fillColor: color } }); startY = doc.autoTable.previous.finalY + 15; }; addReportSection("Skipped (Ineligible) Students", lastSuccessfulResult.skipped_students, ['Branch', 'Skipped USNs'], [231, 76, 60]); addReportSection("Unseated Students", lastSuccessfulResult.unseated_students, ['Branch / Group', 'Count Remaining'], [243, 156, 18]); doc.save('summary-report.pdf'); };
        
        // **CHANGE 2**: This function is updated to add the branch-wise student count.
        const exportRoomLayoutsToPdf = () => {
            if (!lastSuccessfulResult) return;

            const { jsPDF } = window.jspdf;
            const doc = new jsPDF({ orientation: 'l', unit: 'mm', format: 'a4' });
            
            // Create a mapping from USN prefix to Branch Name to identify students
            const prefixToBranchMap = {};
            document.querySelectorAll(".branch-group-wrapper").forEach(group => {
                const name = group.querySelector(".branch-name").value.trim().toUpperCase();
                const prefix = group.querySelector(".branch-prefix").value.trim();
                if (name && prefix) {
                    prefixToBranchMap[prefix] = name;
                }
            });

            lastSuccessfulResult.room_arrangements.forEach((roomPlan, roomIndex) => {
                if (roomIndex > 0) doc.addPage();
                const margin = 10;
                const pageHeight = doc.internal.pageSize.getHeight();
                const pageWidth = doc.internal.pageSize.getWidth();

                // Calculate branch-wise student counts for the current room
                const roomBranchCounts = {};
                roomPlan.arrangement_by_column.forEach(column => {
                    column.seating_plan.forEach(bench => {
                        bench.seats.forEach(usn => {
                            if (usn && usn !== "---") {
                                for (const prefix in prefixToBranchMap) {
                                    if (usn.startsWith(prefix)) {
                                        const branchName = prefixToBranchMap[prefix];
                                        roomBranchCounts[branchName] = (roomBranchCounts[branchName] || 0) + 1;
                                        break; 
                                    }
                                }
                            }
                        });
                    });
                });
                
                doc.setFontSize(18);
                doc.setFont(undefined, 'bold');
                doc.text(`CLASS ROOM NUMBER: ${roomPlan.room_name}`, pageWidth / 2, margin + 5, { align: 'center' });
                doc.setFont(undefined, 'normal');

                let maxFinalY = margin + 12; // Track the lowest point of the tables

                roomPlan.arrangement_by_column.forEach((columnGroup, colIndex) => {
                    const numColumns = roomPlan.arrangement_by_column.length;
                    const availableWidth = pageWidth - (2 * margin);
                    const columnWidth = availableWidth / numColumns;
                    const startX = margin + (colIndex * columnWidth);
                    const head = [['Bench', ...lastSuccessfulResult.student_seat_headers.map((h, i) => `Seat ${String.fromCharCode(65 + i)}`)]];
                    const body = columnGroup.seating_plan.map(bench => [bench.bench_number, ...bench.seats]);
                    
                    doc.autoTable({
                        head: head, body: body, startY: margin + 12, theme: 'grid',
                        headStyles: { fillColor: [44, 62, 80], textColor: 255, fontSize: 9 },
                        bodyStyles: { fontSize: 9, cellPadding: 1.5 },
                        columnStyles: { 0: { fontStyle: 'bold', cellWidth: 14 } },
                        margin: { left: startX, right: pageWidth - (startX + columnWidth) },
                        tableWidth: 'auto'
                    });
                    if (doc.autoTable.previous.finalY > maxFinalY) {
                        maxFinalY = doc.autoTable.previous.finalY;
                    }
                });

                // Add the summary text at the bottom of the page
                if (Object.keys(roomBranchCounts).length > 0) {
                    const summaryText = "Room Summary: " + Object.entries(roomBranchCounts)
                        .map(([branch, count]) => `${branch}: ${count} student(s)`)
                        .join('   |   ');
                    
                    if (maxFinalY > pageHeight - 25) { // Add new page if space is tight
                        doc.addPage();
                        maxFinalY = margin;
                    }
                    doc.setFontSize(10);
                    doc.setFont(undefined, 'bold');
                    doc.text(summaryText, margin, maxFinalY + 12);
                }
            });

            doc.save('classroom-seating-layouts.pdf');
        };

        const displayResults = (data) => { let statusHTML = ''; const skipped = data.skipped_students; if (skipped && Object.keys(skipped).length > 0) { statusHTML += `<div id="status" class="status-info" style="margin-bottom:1rem"><strong>Skipped (ineligible):</strong><ul style="margin-top:.5rem;columns:2;list-style-position:inside">`; Object.entries(skipped).forEach(([e,s])=>{statusHTML+=`<li><b>${e}:</b> ${s.join(", ")}</li>`}); statusHTML += `</ul></div>`; } const unseated = data.unseated_students; const hasUnseated = unseated && Object.values(unseated).some(list => list.length > 0); if (hasUnseated) { statusHTML += `<div id="status" class="status-warning"><strong>Warning: Some students unseated.</strong><ul style="margin-top:.5rem;list-style-position:inside">`; Object.entries(unseated).forEach(([o,s])=>{if(s.length>0)statusHTML+=`<li><b>${o}:</b> ${s.length} student(s) remain.</li>`}); statusHTML += `</ul></div>`; } statusContainer.innerHTML = statusHTML; let resultsHTML = ` <div class="results-header"> <h2>Generated Seating Plans</h2> <div> <button id="exportLayoutsBtn" class="export-btn">Export Room Layouts (PDF)</button> <button id="exportReportBtn" class="export-btn report-btn">Export Summary Report (PDF)</button> </div> </div> <div id="resultsTableContainer" style="margin-top: 1rem;">`; data.room_arrangements.forEach(roomPlan => { resultsHTML += `<div class="room-plan-group"><h2>${roomPlan.room_name}</h2>`; roomPlan.arrangement_by_column.forEach(columnGroup => { resultsHTML += `<div><h3>${columnGroup.name}</h3>`; resultsHTML += `<table><thead><tr><th>Bench #</th>`; data.student_seat_headers.forEach(header => { resultsHTML += `<th>${header}</th>`; }); resultsHTML += '</tr></thead><tbody>'; columnGroup.seating_plan.forEach(bench => { resultsHTML += `<tr><td><b>${bench.bench_number}</b></td>`; bench.seats.forEach(seat => { resultsHTML += `<td>${seat}</td>`; }); resultsHTML += '</tr>'; }); resultsHTML += '</tbody></table></div>'; }); resultsHTML += `</div>`; }); resultsHTML += '</div>'; resultsContainer.innerHTML = resultsHTML; document.getElementById('exportLayoutsBtn').addEventListener('click', exportRoomLayoutsToPdf); document.getElementById('exportReportBtn').addEventListener('click', exportSummaryReport); };
    });
    </script>
</body>
</html>
